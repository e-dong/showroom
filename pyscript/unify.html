<html><head><meta charset="utf-8"><py-config type=json>{"runtimes":[{"src":"pyodide-sdl2/pyodide.js","name":"pyodide-sdl2","lang":"python"}]}</py-config></head><html><pre><py-script>#<!--
PYGBAG_FS = 10
# fmt: off
__import__('os').chdir(__import__('tempfile').gettempdir())
def fs_decode(fsname, o248):
    from pathlib import Path
    filename = Path.cwd() / fsname
    if not filename.is_file():
        filename.parent.mkdir(parents=True, exist_ok=True)
        #print("FS:", filename)
        with open(fsname,"wb") as fs:
            for input in o248.split("\n"):
                if not input: continue
                fs.write(bytes([ord(c) - 248 for c in input]))

fs_decode('assets/background-black.png','''
ƁňņĿąĂĒĂøøøąŁŀļŊøøùƈøøùƈüûøøøŪƉģǷøøøćňńŌĽċĉĉǉǔıžƔǖǎĽħƩęƹĸŖŖĉøøùĻŁļĹŌŰǒǥǕĹŦŻĨĈýň
ŀŲŸǩąĈğƨƼýưǷơŒōƥǌýŊœƁŸĵŶŧƑčīûƾķĹŜƒøøŸšƂĜſĮďċùŖťĶǲŨǏďǒƪĜơǛƩƒĀƕƠŁǢŰŦĞúŸǵčǟƈƋǙǐǔŐü
ǀǊǏĥŅĠūƅĸŻţǝŽŚƴƊėǆůøøŘĸšƪǈƲƐĀĬŜǏúưŌŠùǨƥŢùøøǊħŴŁǫǤŗāċùøøĸžƏǙǷƣƒĀøøøøǔĜŲħƸůżøøøøǯ
ǩĒĲŸīƥŒøøøøøøĸīĚŁĕūđŧĚƃǋďøŸǜŮŽǈţľǥǳǨǋƼŅƱđøŤƣƸƱŀƃĺƲúƨƬúƸſşƎĺƮŢĚøŨƉįĥŸƗŞŽŨƃňōǃƏŋĩ
ĉøøøƉûøǠƻǟƗǙǱƍüĸŬƛŽĳĪƸŗǧľŮǨŔƘŢùŻłƫƼƎĨĉøøĐĮƢǐĿėƣŒøøøǨŊƙýşǨĘđǨƓĽăøĸƮúøŘŔǧāħþǗǦƍįĮ
øøøøŁĽņļƦĺŘź''')

fs_decode('assets/pixel_laser_blue.png','''
ƁňņĿąĂĒĂøøøąŁŀļŊøøøŜøøøŒùûøøøŬŔřǂøøøāŨŀőūøøăċøøăċùøƒƔĐøøøþňńŌĽĿŨńŅƕǘŻƅƄǥøøøùŬŊņ
ŋøĸǞǐŞøøøĐŁļĹŌİǃśŘĐýŻÿƨǷēǝąŮǖĠĐƢøøƟǔĖƏŬƦŻƱøøøøŁĽņļƦĺŘź''')

fs_decode('assets/pixel_laser_green.png','''
ƁňņĿąĂĒĂøøøąŁŀļŊøøøŜøøøŒùûøøøŬŔřǂøøøāŨŀőūøøăċøøăċùøƒƔĐøøøþňńŌĽĿŨńĳƪūƠǣŚƔøøøùŬŊņ
ŋøĸǞǐŞøøøĐŁļĹŌİǃśŘĐýŻÿƨǷēǝąŮǖĠĐƢøøƟǔĖƏŬƦŻƱøøøøŁĽņļƦĺŘź''')

fs_decode('assets/pixel_laser_red.png','''
ƁňņĿąĂĒĂøøøąŁŀļŊøøøŜøøøŒùûøøøŬŔřǂøøøāŨŀőūøøăċøøăċùøƒƔĐøøøþňńŌĽĿŨńǙōŌƔƸúĲøøøùŬŊņ
ŋøĸǞǐŞøøøĐŁļĹŌİǃśŘĐýŻÿƨǷēǝąŮǖĠĐƢøøƟǔĖƏŬƦŻƱøøøøŁĽņļƦĺŘź''')

fs_decode('assets/pixel_laser_yellow.png','''
ƁňņĿąĂĒĂøøøąŁŀļŊøøøŜøøøŒùûøøøŬŔřǂøøøāŨŀőūøøăċøøăċùøƒƔĐøøøþňńŌĽĿŨńǙƴġĵǀĿĖøøøùŬŊņ
ŋøĸǞǐŞøøøĐŁļĹŌİǃśŘĐýŻÿƨǷēǝąŮǖĠĐƢøøƟǔĖƏŬƦŻƱøøøøŁĽņļƦĺŘź''')

fs_decode('assets/pixel_ship_blue_small.png','''
ƁňņĿąĂĒĂøøøąŁŀļŊøøøĪøøøĪúûøøøśŉŘĚøøøāňńŌĽĿŨńŌőŎĖƿǲƍŲŢĿøøøùŬŊņŋøĸǞǐŞøøøĘŁļĹŌĠǇśŘ
ĐŤĘĬĬŘƌſǆśąąŕƭŢšŠǠŘǘąĒøøŇŏĬƵŧøƁƩøøøøŁĽņļƦĺŘź''')

fs_decode('assets/pixel_ship_green_small.png','''
ƁňņĿąĂĒĂøøøąŁŀļŊøøøľøøøĪúûøøøƔǫĽƸøøøāňńŌĽĿŨńŌőŎĳƪūťǈŐųøøøùŬŊņŋøĸǞǐŞøøøĝŁļĹŌĠǇśŘ
ĐĆŸĭĬŬǀĂŽžľƥŒčĒĒĨüŽĈŶŹƫžƈǈĈþøƘǩĭƯƫƧƊƖøøøøŁĽņļƦĺŘź''')

fs_decode('assets/pixel_ship_red_small.png','''
ƁňņĿąĂĒĂøøøąŁŀļŊøøøľøøøĪúûøøøƔǫĽƸøøøāŨŀőūøøăċøøăċùøƒƔĐøøøāňńŌĽĿŨńźƂŽǙōŌşĠǌĉøøøù
ŬŊņŋøĸǞǐŞøøøĝŁļĹŌĠǇśŘĐĆŸĭĬŬǀĂŽžľƥŒčĒĒĨüŽĈŶŹƫžƈǈĈþøƘǩĭƯƫƧƊƖøøøøŁĽņļƦĺŘź''')

fs_decode('assets/pixel_ship_yellow.png','''
ƁňņĿąĂĒĂøøøąŁŀļŊøøøŜøøøŒúûøøøīǴēĒøøøāŨŀőūøøăċøøăċùøƒƔĐøøøĄňńŌĽĿŨńưƼƵǙƴġƺǇƿŁĐǂĞø
øøùŬŊņŋøĸǞǐŞøøøĲŁļĹŌŀƿśŘĐýŀĘČüľŝľŝľƲĄţŠǠĢĈĀąąĐƍđƑĪŔƣŎǵǷǷčĦċǷǷǷƢōăľŝľƔǄƀħċùţħƧƬż
ŋĜǛøøøøŁĽņļƦĺŘź''')

# fmt:on
del fs_decode, PYGBAG_FS

import sys

print(f"{sys.platform=}\n{sys.version}")

if sys.platform == "emscripten":
    try:
        # pygbag
        from embed import HTML
        import js

        print("pygbag")
    except ModuleNotFoundError:
        # pyscript
        import js
        import pyodide.ffi

        print("pyscript")

        class HTML:
            def __init__(self, file="stdout"):
                self.file = file
                self.buffer = []
                self.ctx = 0

            def __call__(self, *argv, **kw):
                sys.__stderr__.write(f"HTML {argv}")
                kw.setdefault("end", "\n")
                kw.setdefault("pre", "  " * self.ctx)
                for pos, arg in enumerate(argv):
                    pre = ""
                    suf = ""
                    if not pos:
                        pre
                    else:
                        pre = ""
                    arg = arg.replace("py-click=", 'onclick="route(event)" py-click=')
                    o_len = len(arg)
                    arg = arg.rstrip("'")
                    arg = eval(f"f'''{arg}'''") + "'" * (len(arg) - o_len)
                    self.buffer.append(kw["pre"] + arg + kw["end"])
                if not self.ctx:
                    self.flush()

            def read(self):
                return str().join(self.buffer)

            def flush(self):
                import js

                extend = js.document.createElement("div")
                extend.innerHTML = self.read()
                jsid(self.file).appendChild(extend)
                self.buffer.clear()

            def __enter__(self):
                self.ctx += 1
                return self

            def __exit__(self, *_):
                self.ctx -= 1
                if not self.ctx:
                    self.flush()

        __import__("js").window.eval(
            """
            try {
                rpc
            } catch (x) {
                window.rpc = {}
                window.rpc.path = []
                window.rpc.call = ""
                window.rpc.argv = []
            }

            function bridge(host) {
                const pybr = new Proxy(function () {}, {
                get(_, k, receiver) {
                    rpc.path.push(k)
                    return pybr
                },
                apply(_, o, argv) {
                    const method = rpc.path.join(".")
                    if (host === window.python) {
// TODO: rpc id and serialisation
                        queue_event("rpc", { "call": method, "argv" : argv, "rpcid": window.event} )
                    } else {
                        window.rpc.call = method
                        window.rpc.argv = Array.from(argv)
                        if (!argv.length) {
                            console.error("event should always be first param")
                            window.rpc.argv.unshift(window.event)
                        } else if (argv.length>0 && (window.event!==argv[0])) {
                            console.error("event should always be first param")
                            window.rpc.argv.unshift(window.event)
                        }
                        host.click()
                    }
                    rpc.path.length=0
                }
              });
              return pybr
            }

            window.py = bridge(py_router)
// onclick() case, which is BAD, deprecated and used.
            window.route = function router(event) {
                window.rpc.argv = [event]
                window.rpc.call = event.target.getAttribute("py-click")
                py_router.click()
            }
        """
        )
        # Read data from Emscripten Filesystem
        ObjectURLs = {}

        def File(path):
            global ObjectURLs
            from js import window
            import pyodide.ffi

            filename = str(path)
            bloburl = ObjectURLs.get(filename, None)
            if bloburl is None:
                with open(filename, "rb") as fp:
                    data_from_FS = fp.read()
                jsfile = window.File.new([pyodide.ffi.to_js(data_from_FS)], filename)
                bloburl = window.URL.createObjectURL(jsfile)
                ObjectURLs[filename] = bloburl
            return bloburl

        def new(oclass, *argv):
            return getattr(oclass, "new")(*argv)

        def jsid(elemid):
            # Element(str(elemid)).element
            return js.document.getElementById(str(elemid))

        def jsattr(query, attr):
            if isinstance(query, str):
                return js.document.getElementById(str(query)).getAttribute(attr)
            return query.getAttribute(attr)

        import builtins

        builtins.new = new
        builtins.File = File
        builtins.html = HTML()
        builtins.jsid = jsid
        builtins.jsattr = jsattr

        #
        def py_route(*argv):
            py.route(*argv)

        class py:
            @classmethod
            def route(cls, *argv):
                import js
                import builtins

                # recover this, event and maybe argv
                host = __import__("__main__")
                client = str(js.window.rpc.call).rstrip("()")
                argv = tuple(js.window.rpc.argv)
                if not len(argv):
                    console.log("bad call", client)
                    return
                else:
                    event = argv[0]
                    this = event.target

                # expand dot path
                route = client.split(".")
                call = host
                while len(route):
                    step = route.pop(0)
                    if hasattr(call, step):
                        call = getattr(call, step)

                if call is host:
                    print(f"py.route not found {client=} {event=} {this=} {argv=} {type(argv)} {len(argv)}")
                else:
                    # print(f"py.route found {client=} {event=} {this=} {argv=} {type(argv)} {len(argv)}")

                    # call with good number of args
                    argc = call.__code__.co_argcount
                    if (argc == 0) and not len(call.__code__.co_varnames):
                        print(f"argument less call {client=}() is DEPRECATED use {client}(event)")
                        builtins.event = event
                        builtins.this = event.target
                        call()
                    else:
                        # varargs
                        call(*argv)


import os
from pathlib import Path

print("<br>")


# normally event.target === this
def make_pic(event):
    this = event.target
    jsid("pic").src = File(jsattr(this, "data-src"))


def make_pic_noargs():
    jsid("pic").src = File(jsattr(this, "data-src"))


def make_click():
    print(f"make_click() {event=} {type(event)=}")
    jsid("pic").src = File(jsattr(event.target, "data-src"))


def listen_click(event):
    console.log(f"got {event=} from {event.target=}")
    jsid("pic").src = File(jsattr(event.target, "data-src"))


print("Hello")

from js import window


with html as printf:
    path = Path("/tmp/assets")
    for bid, fname in enumerate(os.listdir(path)):
        printf("")
        if bid == 0:
            printf("with py-click=make_click()  BAD")
            printf('<button id="b{bid}" data-src="{path/fname}" py-click="make_click()">{fname}</button>')
        elif bid == 1:
            printf(
                "with onclick=py.make_pic_noargs()  BAD but just work and less typing:  uses implicit event/this (builtins) on python side"
            )
            printf('<button id="b{bid}" data-src="{path/fname}" onclick="py.make_pic_noargs()">{fname}</button>')
        elif bid == 2:
            printf("with onclick=py.make_pic(event)  BETTER but still use window.event js side")
            printf('<button id="b{bid}" data-src="{path/fname}" onclick="py.make_pic(event)">{fname}</button>')
        elif bid == 3:
            printf("with addEventListener (will pass only event)  BEST")
            printf('<button id="b{bid}" data-src="{path/fname}">{fname}</button>', "<hr>")
            printf.flush()
            jsid(f"b{bid}").addEventListener("click", pyodide.ffi.create_proxy(listen_click))
        else:
            printf('<button id="b{bid}" data-src="{path/fname}" onclick="py.make_pic(event)">{fname}</button>')

    printf('<br><hr><img id=pic height=200 alt="show image" border=1>')

    printf('<canvas id="canvas" width="1024" height="600" style="background-color:#404040"></canvas>')


jsid("pic").src = "../imgs/lcd.gif"


import ctypes
print(ctypes)

cdll = ctypes.CDLL(None)



def dll(*argv):
    print(getattr(cdll, argv[0])(*argv[1:]))

#dll("emscripten_run_script", "console.log(666)" )
#window.eval("console.log(_pyodide)")



if 1:
    from pyodide.http import pyfetch
    response = await pyfetch("pygame-2.1.3.dev5-cp310-cp310-wasm32_mvp_emscripten.whl") # .zip, .whl, ...
    await response.unpack_archive() # by default, unpacks to the current dir

    import micropip
    micropip.install("pygame-2.1.3.dev5-cp310-cp310-wasm32_mvp_emscripten.whl")

    import os
    os.chdir('pygame')
    #for f in os.listdir('.'):
    #    print(f)
    sys.path.insert(0, '.')
    import pygame_static
    print(pygame_static)
else:
    import pyodide
    pyodide.loadPackage("pygame-2.1.3.dev5-cp310-cp310-wasm32_mvp_emscripten.whl")


#pkg.do_something();
#dll( "emscripten_run_preload_plugins", "/", None , None)


def download_file():
    global tempfile
    hidden_link = document.createElement("a")
    hidden_link.download = tempfile.rsplit("/")[-1]
    hidden_link.href = File(tempfile)
    hidden_link.click()


# fmt: off
# --></py-script><script src="https://pyscript.net/releases/2022.09.1/pyscript.js" defer></script><div id=py_router py-click="py_route()" hidden></div><div id="stdout"></div></pre></html>
